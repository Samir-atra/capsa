<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>capsa.risk_tensor - capsa documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">capsa  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">capsa  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/index.html">üëã Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/installation.html">üíæ Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../risk_metrics/index.html">‚≠êÔ∏è Risk Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/basic_usage.html">üé¨ Basic Usage</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../tutorials/index.html">üë©‚Äçüè´ Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/1_Ensemble-Classification.html">Ensemble Wrapper (Classification)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/2_Histogram-Classification.html">Histogram Wrapper (Classification)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/3_MVE-Classification.html">MVE Wrapper (Classification)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/4_MVE-Regression.html">MVE Wrapper (Regression)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/5_High-Dimensional-Depth.html">High Level Introduction to Capsa with a Real World Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/6_OOD-Detection.html">Anomaly Detection (Advanced)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/notebooks/7_Composability.html">Composability (Advanced)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api_documentation/index.html">‚Äçüíª Metric Wrapper API</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/BaseWrapper.html">BaseWrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/RiskTensor.html">RiskTensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/MVEWrapper.html">MVEWrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/VAEWrapper.html">VAEWrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/EnsembleWrapper.html">EnsembleWrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/DropoutWrapper.html">DropoutWrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/HistogramWrapper.html">HistogramWrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api_documentation/HistogramVAEWrapper.html">HistogramVAEWrapper</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">üßø Contribute</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for capsa.risk_tensor</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="kn">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="kn">import</span> <span class="n">math_ops</span><span class="p">,</span> <span class="n">array_ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util</span> <span class="kn">import</span> <span class="n">tf_decorator</span><span class="p">,</span> <span class="n">dispatch</span>

<span class="n">NoneType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_right</span><span class="p">(</span><span class="n">operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Right-handed version of an operator: swap args ``x`` and ``y``.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tf_decorator</span><span class="o">.</span><span class="n">make_decorator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_dummy_bool</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dummy method to prevent a ``RiskTensor`` from being used as a Python ``bool``.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;RiskTensor may not be used as a boolean.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="RiskTensor"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor">[docs]</a><span class="k">class</span> <span class="nc">RiskTensor</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">BatchableExtensionType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extends the interface defined by the ``tf.Tensor`` type (tensor-like extension type</span>
<span class="sd">    see `tf.extension_type &lt;https://www.tensorflow.org/guide/extension_type&gt;`_ for more details).</span>

<span class="sd">    An instance of this class contains both ``y_hat`` and the risk</span>
<span class="sd">    measures inside of it (which can be accessed). The output of</span>
<span class="sd">    every wrapper is a ``RiskTensor``. We represent a risk tensor</span>
<span class="sd">    as four separate dense tensors: ``y_hat``, ``aleatoric``, ``epistemic``,</span>
<span class="sd">    and ``bias`` (anyone of those could be ``None`` besides ``y_hat``),</span>
<span class="sd">    these tensors are collected into a ``RiskTensor``</span>
<span class="sd">    class for ease of use.</span>

<span class="sd">    The default behavior of this object mimics one of a regular ``tf.Tensor``:</span>
<span class="sd">        - has a ``shape``, and a ``dtype``;</span>
<span class="sd">        - could be used with Tensor operations (such as ``tf.stack``, ``tf.concat``,</span>
<span class="sd">          ``tf.shape``, ``tf.add``, ``tf.math.reduce_std``, ``tf.reduce_mean``, etc.);</span>
<span class="sd">        - could be used as input/output for ``tf.keras.Model`` and ``tf.keras.layers``;</span>
<span class="sd">        - could be used with ``tf.data.Dataset``;</span>
<span class="sd">        - `etc &lt;https://www.tensorflow.org/guide/extension_type#supported_apis&gt;`_.</span>

<span class="sd">    Note: Not all `tf operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_api&gt;`_</span>
<span class="sd">    are currently supported to work natively with an instance of the ``RiskTensor``. The ones that are currently</span>
<span class="sd">    supported are: (i) all `unary elementwise operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_unary_elementwise_apis&gt;`_;</span>
<span class="sd">    (ii) all `binary elementwise operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_binary_elementwise_apis&gt;`_;</span>
<span class="sd">    (iii) the following `operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_api&gt;`_</span>
<span class="sd">    ``tf.math.reduce_std``, ``tf.reduce_mean``, ``tf.reduce_sum``, ``tf.stack``, ``tf.concat``, ``tf.shape``, ``tf.reshape``,</span>
<span class="sd">    ``tf.size``, ``tf.transpose``, ``tf.matmul``, ``tf.convert_to_tensor``, ``tf.where``, ``tf.debugging.assert_near``,</span>
<span class="sd">    ``tf.debugging.assert_equal``.</span>

<span class="sd">    When working with ``RiskTensor``, if you encounter an unexpected error most likely the tensorflow framework under the hood</span>
<span class="sd">    tries to use one of the `tf operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_api&gt;`_</span>
<span class="sd">    which is not currently supported -- thus you may need to override the default behavior of the specified tf</span>
<span class="sd">    operation when it is called. You can use the ``@tf.experimental.dispatch_for_api`` decorator to specify</span>
<span class="sd">    how a not yet supported operation (e.g., ``tf.reduce_max()``) should process ``RiskTensor`` values.</span>
<span class="sd">    For more examples see ``capsa/risk_tensor.py``.</span>

<span class="sd">    Note: the ``RiskTensor`` class overloads the standard Python arithmetic and comparison operators, making it easy to perform basic math.</span>
<span class="sd">    ``RiskTensor`` overloads the same set of operators as ``tf.Tensor``: the unary operators ``-``, ``~``, and ``abs()``;</span>
<span class="sd">    and the binary operators ``+``, ``-``, ``*``, ``/``, ``//``, ``%``, ``**``, ``&amp;``, ``|``, ``^``, ``==``, ``&lt;``, ``&lt;=``, ``&gt;``, and ``&gt;=``.</span>
<span class="sd">    ``RiskTensor`` also supports Python-style indexing, including multidimensional indexing and slicing.</span>
<span class="sd">    For more examples see ``test/test_risk_tensor.py``.</span>

<span class="sd">    Example usage:</span>
<span class="sd">        &gt;&gt;&gt; # initialize a keras model</span>
<span class="sd">        &gt;&gt;&gt; user_model = Unet()</span>
<span class="sd">        &gt;&gt;&gt; # wrap the model to transform it into a risk-aware variant (e.g. with the vae wrapper)</span>
<span class="sd">        &gt;&gt;&gt; model = VAEWrapper(user_model)</span>
<span class="sd">        &gt;&gt;&gt; # compile and fit as a regular keras model</span>
<span class="sd">        &gt;&gt;&gt; model.compile(...)</span>
<span class="sd">        &gt;&gt;&gt; model.fit(...)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # output of a metric wrapper is a ``RiskTensor``. It acts like a regular</span>
<span class="sd">        &gt;&gt;&gt; # ``tf.Tensor`` -- as it was before a user wrapped their model with capsa</span>
<span class="sd">        &gt;&gt;&gt; output = model(x)   # type(output) == capsa.RiskTensor</span>
<span class="sd">        &gt;&gt;&gt; # in other words, using ``output`` feels the same as directly using ``y_hat``</span>
<span class="sd">        &gt;&gt;&gt; real_tensor = tf.random.uniform(shape=output.shape)   # type(real_tensor) == tf.Tensor</span>
<span class="sd">        &gt;&gt;&gt; output + real_tensor</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # but in addition to the model&#39;s prediction (y_hat) we can access risk measures as</span>
<span class="sd">        &gt;&gt;&gt; # part of the RiskTensor</span>
<span class="sd">        &gt;&gt;&gt; output.epistemic #  to return a tf.Tensor of the epistemic uncertainty</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># required for serialization in tf.saved_model</span>
    <span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;capsa.RiskTensor&quot;</span>

    <span class="c1"># if we have e.g. array + risk_tensor -- from the perspective</span>
    <span class="c1"># of the array it should call its __add__ method, but from the</span>
    <span class="c1"># perspective of the risk_tensor it should call its __radd__ method.</span>
    <span class="c1"># The problem was that numpy&#39;s __add__ was called in these cases</span>
    <span class="c1"># which resulted in an error as numpy cannot handle operations with</span>
    <span class="c1"># risk tensors (error message was the same as calling np.add(array, risk_tensor)).</span>
    <span class="c1">#</span>
    <span class="c1"># The line below enables the Tensor&#39;s overloaded &quot;right&quot; binary</span>
    <span class="c1"># operators to run when the left operand is an ndarray, because it</span>
    <span class="c1"># accords the Tensor class higher priority than an ndarray.</span>
    <span class="c1"># In other words, TensorFlow NumPy defines an __array_priority__</span>
    <span class="c1"># higher than NumPy&#39;s.This means that for operators involving both</span>
    <span class="c1"># tf.tensor array and np.ndarray, the former will take precedence, i.e.,</span>
    <span class="c1"># TensorFlow&#39;s implementation of the operator will get invoked.</span>
    <span class="c1">#</span>
    <span class="c1"># Relevant links:</span>
    <span class="c1"># related issue https://github.com/tensorflow/tensorflow/issues/2289</span>
    <span class="c1"># the same solution is used for the tf.Tensor https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/framework/ops.py#L913-L920</span>
    <span class="c1"># patch https://github.com/tensorflow/tensorflow/commit/a8c3de3bddf01b4b80c986b3bb81d2a1658be3c8</span>
    <span class="c1"># see also https://github.com/tensorflow/tensorflow/issues/8051#issuecomment-285505805</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="c1"># The default ExtensionTypeBatchEncoder that is used by BatchableExtensionType assumes</span>
    <span class="c1"># and creates batchs of RiskTensor values by simply stacking individual risk tensors (y_hat, aleatoric,</span>
    <span class="c1"># epistemic and bias).</span>

    <span class="n">y_hat</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="n">aleatoric</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">epistemic</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># use y_hat&#39;s shape and dtype when checking these params on an instance of the RiskTensor</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="n">dtype</span>

<div class="viewcode-block" id="RiskTensor.__validate__"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.__validate__">[docs]</a>    <span class="k">def</span> <span class="nf">__validate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``tf.ExtensionType`` adds a validation method (``__validate__``), to perform validation checks on fields.</span>
<span class="sd">        It is run after the constructor is called, and after fields have been type-checked and converted</span>
<span class="sd">        to their declared types, so it can assume that all fields have their declared types.</span>

<span class="sd">        We override this method to validate the shapes and dtypes of ``RiskTensor``&#39;s fields.</span>
<span class="sd">        This method asserts that if a risk estimate is provided (e.g. if aleatoric is not ``None``),</span>
<span class="sd">        the shape of this aleatoric tensor should match the shape of ``y_hat``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">assert_is_compatible_with</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">assert_is_compatible_with</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">assert_is_compatible_with</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="RiskTensor.__repr__"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``tf.ExtensionType`` adds a default printable representation method (``__repr__``). We override</span>
<span class="sd">        this default string conversion operator to generate a more readable string representation</span>
<span class="sd">        when values are printed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        risk_str : str</span>
<span class="sd">            Printable representation of an object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if hasattr(self.y_hat, &quot;numpy&quot;):</span>
        <span class="c1">#     y_hat = &quot; &quot;.join(str(self.y_hat.numpy()).split())</span>

        <span class="c1"># &quot;RiskTensor(y_hat=%s, aleatoric=%s, epistemic=%s, self.bias=%s, dense_shape=%s)&quot; % (self.y_hat,\</span>
        <span class="c1">#  self.aleatoric, self.epistemic, self.bias)</span>

        <span class="n">risk_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">risk_str</span> <span class="o">+=</span> <span class="s2">&quot;aleatoric, &quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">risk_str</span> <span class="o">+=</span> <span class="s2">&quot;epistemic, &quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">risk_str</span> <span class="o">+=</span> <span class="s2">&quot;bias, &quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">risk_str</span> <span class="o">=</span> <span class="n">risk_str</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">if</span> <span class="n">risk_str</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;RiskTensor: shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, risk=(</span><span class="si">{</span><span class="n">risk_str</span><span class="si">}</span><span class="s2">)&gt;&quot;</span></div>

<div class="viewcode-block" id="RiskTensor.__getitem__"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_spec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overload for ``RiskTensor.getitem``. This operation extracts the specified region from the tensor.</span>
<span class="sd">        The notation is similar to ``tf.Tensor``.</span>

<span class="sd">        Note: applies to all elements of a ``RiskTensor`` (not only ``y_hat``) reasoning behind such a design</span>
<span class="sd">        choice is that in this scenario when a user extracts a slice from a given tensor there is no need</span>
<span class="sd">        to keep around elements of risk tensors that correspond to the elements of ``y_hat`` that do not</span>
<span class="sd">        exist anymore (after slicing). Thus no need to protect a user from accidentally modifying the contents</span>
<span class="sd">        of the risk tensors. Also if we slice only ``y_hat`` leaving risk tensors untouched that would violate our own</span>
<span class="sd">        ``__validate__`` method as the ``y_hat`` tensor and each of the risk tensors will have different shapes.</span>

<span class="sd">        For more examples see ``test/test_risk_tensor.py``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        slice_spec : slice</span>
<span class="sd">            The arguments to ``RiskTensor.__getitem__``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : capsa.RiskTensor</span>
<span class="sd">            The appropriate slice of a risk tensor, based on ``slice_spec``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># note on __getitem__:</span>
        <span class="c1">#</span>
        <span class="c1"># implementation for the tf.Tensor could be found</span>
        <span class="c1">#   - ops.Tensor._override_operator(&quot;__getitem__&quot;, _slice_helper)</span>
        <span class="c1">#   - _slice_helper -- https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/array_ops.py#L913-L1107</span>
        <span class="c1">#     This method is exposed in TensorFlow&#39;s API so that library developers can register dispatching</span>
        <span class="c1">#     for `Tensor.__getitem__` to allow it to handle custom composite tensors &amp; other custom objects.</span>
        <span class="c1"># subclassing BatchableExtensionType</span>
        <span class="c1">#   - uses __getitem__ directly https://github.com/tensorflow/tensorflow/blob/fed8a5fe044e0ec03d7cc854b0107ddaf9148c70/tensorflow/python/ops/ragged/ragged_tensor_supported_values_test.py#L54-L55</span>
        <span class="c1"># Ragged Tensor</span>
        <span class="c1">#   - https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/ragged/ragged_getitem.py#L189</span>
        <span class="c1"># TF tests</span>
        <span class="c1">#   - https://github.com/tensorflow/tensorflow/blob/6c3ede21130d3d7e76acc87816d6d99539006699/tensorflow/python/ops/ragged/ragged_getitem_test.py#L143-L145</span>
        <span class="c1">#   - https://github.com/tensorflow/tensorflow/blob/e07c81116c62a6bffbed2485ba5bf9167346b902/tensorflow/python/ops/structured/structured_tensor_slice_test.py#L213-L215</span>
        <span class="c1">#   - https://github.com/tensorflow/tensorflow/blob/717ca98d8c3bba348ff62281fdf38dcb5ea1ec92/tensorflow/python/kernel_tests/array_ops/array_ops_test.py#L579-L580</span>

        <span class="k">return</span> <span class="n">RiskTensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">slice_spec</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">slice_spec</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">slice_spec</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">slice_spec</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="RiskTensor.__len__"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : int</span>
<span class="sd">            The length of the first dimension of the ``y_hat`` Tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span></div>

    <span class="c1"># note on operator overloading:</span>
    <span class="c1">#</span>
    <span class="c1"># ``tf.RuggedTensor`` also:</span>
    <span class="c1"># 1. registers unary and binary API handlers for dispatch -- https://github.com/tensorflow/tensorflow/blob/2b7a2d357869264f5dab700af6e1ce95bbc28df6/tensorflow/python/ops/ragged/ragged_dispatch.py#L28-L78</span>
    <span class="c1"># 2. registering dispatch handlers allows to use many standard TF ops without overriding each one of them</span>
    <span class="c1">#    (e.g., we can use all binary ops since we&#39;ve created binary_elementwise_op_handler).</span>
    <span class="c1">#       - just defines in a separate file https://github.com/tensorflow/tensorflow/blob/2b7a2d357869264f5dab700af6e1ce95bbc28df6/tensorflow/python/ops/ragged/ragged_operators.py</span>
    <span class="c1">#       - uses them in the main class https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/ragged/ragged_tensor.py#L2169-L2215</span>
    <span class="c1">#       - the elementwise ops https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/math_ops.py</span>
    <span class="c1">#</span>
    <span class="c1"># It appears that calling the individual ops like this (__add__ = tf.add(x, y))</span>
    <span class="c1"># is equivalent to calling them through math ops (__add__ = math_ops.add).</span>
    <span class="c1"># We follow RuggedTensor&#39;s implementation and use the latter way.</span>
    <span class="c1">#</span>
    <span class="c1"># Note: For docs of the functions that we use below for operator overloading see https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/math_ops.py</span>
    <span class="c1"># but note they describe behavior of tf.Tensor. For RiskTensor behavior is essentially</span>
    <span class="c1"># the same but slightly modified by our &#39;unary_elementwise_op_handler&#39; and our</span>
    <span class="c1"># &#39;binary_elementwise_op_handler&#39; (please see their docs in this file),</span>
    <span class="c1"># depending on whether or not an opp is binary or unary.</span>

    <span class="c1"># Ordering operators</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">greater_equal</span>  <span class="c1"># binary</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">greater</span>  <span class="c1"># binary</span>
    <span class="fm">__le__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">less_equal</span>  <span class="c1"># binary</span>
    <span class="fm">__lt__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">less</span>  <span class="c1"># binary</span>

    <span class="c1"># Logical operators</span>
    <span class="fm">__invert__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">logical_not</span>  <span class="c1"># unary</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">logical_and</span>  <span class="c1"># binary</span>
    <span class="fm">__rand__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">logical_and</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">logical_or</span>  <span class="c1"># binary</span>
    <span class="fm">__ror__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">logical_or</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__xor__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">logical_xor</span>  <span class="c1"># binary</span>
    <span class="fm">__rxor__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">)</span>  <span class="c1"># binary</span>

    <span class="c1"># Arithmetic operators</span>
    <span class="fm">__abs__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">abs</span>  <span class="c1"># unary</span>
    <span class="fm">__neg__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">negative</span>  <span class="c1"># unary</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">add</span>  <span class="c1"># binary</span>
    <span class="fm">__radd__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__floordiv__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">floordiv</span>  <span class="c1"># binary</span>
    <span class="fm">__rfloordiv__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">floordiv</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__mod__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">floormod</span>  <span class="c1"># binary</span>
    <span class="fm">__rmod__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">floormod</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">multiply</span>  <span class="c1"># binary</span>
    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">multiply</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">pow</span>  <span class="c1"># binary</span>
    <span class="fm">__rpow__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">pow</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">subtract</span>  <span class="c1"># binary</span>
    <span class="fm">__rsub__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">truediv</span>  <span class="c1"># binary</span>
    <span class="fm">__rtruediv__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">truediv</span><span class="p">)</span>  <span class="c1"># binary</span>
    <span class="fm">__matmul__</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">matmul</span>  <span class="c1"># binary</span>
    <span class="fm">__rmatmul__</span> <span class="o">=</span> <span class="n">_right</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">matmul</span><span class="p">)</span>  <span class="c1"># binary</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">_dummy_bool</span>

    <span class="c1"># Equality -- no need to override as tf.extension_type already provides those</span>
    <span class="c1"># __eq__ = math_ops.tensor_equals</span>
    <span class="c1"># __ne__ = math_ops.tensor_not_equals</span>

<div class="viewcode-block" id="RiskTensor.replace_risk"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.replace_risk">[docs]</a>    <span class="k">def</span> <span class="nf">replace_risk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_aleatoric</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">,</span> <span class="n">new_epistemic</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">,</span> <span class="n">new_bias</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In TensorFlow all ``tf.Tensors`` are immutable: you can never update the contents</span>
<span class="sd">        of a tensor, only create a new one `reference &lt;https://www.tensorflow.org/guide/tensor&gt;`_.</span>
<span class="sd">        Mutable objects may be backed by a Tensor which holds the unique handle that identifies</span>
<span class="sd">        the mutable object `reference &lt;https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/types/core.py#L46-L47&gt;`_.</span>
<span class="sd">        In other words, normal ``tf.Tensor`` objects are immutable. To store model weights (or other mutable</span>
<span class="sd">        state) ``tf.Variable`` is used `reference &lt;https://www.tensorflow.org/guide/basics#variables&gt;`_.</span>

<span class="sd">        Similarly, `tf.extension_type &lt;https://www.tensorflow.org/guide/extension_type&gt;`_ and therefore</span>
<span class="sd">        an instance of a ``RiskTensor`` is `immutable &lt;https://www.tensorflow.org/guide/extension_type#mutability&gt;`_.</span>
<span class="sd">        Because ``tf.ExtensionType`` overrides the ``__setattr__`` and ``__delattr__`` methods to prevent mutation.</span>
<span class="sd">        This ensures that they can be properly tracked by TensorFlow&#39;s graph-tracing mechanisms.</span>

<span class="sd">        If you find yourself wanting to mutate an extension type value, consider instead using this method that</span>
<span class="sd">        transforms values. For example, rather than defining a ``set_risk`` method to mutate a ``RiskTensor``,</span>
<span class="sd">        you could use the ``replace_risk`` method that returns a new ``RiskTensor``. This is similar to e.g.</span>
<span class="sd">        `implementation &lt;https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/framework/sparse_tensor.py#L177-L200&gt;`_</span>
<span class="sd">        of the ``tf.SparseTensor``.</span>

<span class="sd">        Note: If a value e.g. for the ``new_epistemic`` argument is not provided to replace ``RiskTensor``&#39;s</span>
<span class="sd">        epistemic estimate, the current epistemic estimate will be kept.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_aleatoric : tf.Tensor, default str</span>
<span class="sd">            New aleatoric estimate.</span>
<span class="sd">        new_epistemic : tf.Tensor, default str</span>
<span class="sd">            New epistemic estimate.</span>
<span class="sd">        new_bias : tf.Tensor, default str</span>
<span class="sd">            New bias estimate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : capsa.RiskTensor</span>
<span class="sd">            New risk aware tensor, contains old ``y_hat`` and new risk estimates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assumes that isinstance(x, str) means &quot;keep&quot;, this is reasonable</span>
        <span class="c1"># because risk tensor only expects tf.Tensor or None anyway.</span>
        <span class="c1"># Alternatively, ``is not &quot;keep&quot;`` also works, but gets SyntaxWarning.</span>

        <span class="c1"># Also, in the ExtensionType&#39;s constructor, Tensor fields</span>
        <span class="c1"># are converted using tf.convert_to_tensor. So we don&#39;t need</span>
        <span class="c1"># to convert to tensor explicitly here.</span>

        <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
        <span class="k">return</span> <span class="n">RiskTensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span>
            <span class="n">op</span><span class="p">(</span><span class="n">new_aleatoric</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">),</span>
            <span class="n">op</span><span class="p">(</span><span class="n">new_epistemic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span><span class="p">),</span>
            <span class="n">op</span><span class="p">(</span><span class="n">new_bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="RiskTensor.ndim"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.ndim">[docs]</a>    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : int</span>
<span class="sd">            The number of dimensions of the ``y_hat`` Tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">ndims</span></div>

<div class="viewcode-block" id="RiskTensor.device"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.device">[docs]</a>    <span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : str</span>
<span class="sd">            The name of the device on which this risk tensor will be produced, or ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="n">device</span></div>

<div class="viewcode-block" id="RiskTensor.to_list"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.to_list">[docs]</a>    <span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similarly to ``tf.RaggedTensor``, requires that risk tensor was constructed in eager execution mode.</span>

<span class="sd">        Returns a single nested ``list`` object with the values for the ``RiskTensor``.</span>
<span class="sd">        If an element of a ``RiskTensor`` (e.g. ``RiskTensor.bias``) is ``None`` this method</span>
<span class="sd">        returns ``None`` for the corresponding element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : list</span>
<span class="sd">            A nested Python ``list`` with the values for the ``RiskTensor``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">EagerTensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;RiskTensor.to_list() is only supported in eager mode.&quot;</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">):</span>
                <span class="n">tensor_as_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;to_list&quot;</span><span class="p">):</span>
                <span class="n">tensor_as_list</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">):</span>
                <span class="n">tensor_as_list</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tensor must be convertible to a list&quot;</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor_as_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="RiskTensor.numpy"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.RiskTensor.numpy">[docs]</a>    <span class="k">def</span> <span class="nf">numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similarly to ``tf.RaggedTensor``, requires that risk tensor was constructed</span>
<span class="sd">        in eager execution mode.</span>

<span class="sd">        Returns four ``np.array`` objects, one for each tensor contained in the ``RiskTensor``.</span>
<span class="sd">        If an element of a ``RiskTensor`` (e.g. ``RiskTensor.bias``) is ``None`` this method</span>
<span class="sd">        returns ``np.nan`` for the corresponding element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_hat : np.array</span>
<span class="sd">            Represents ``RiskTensor.y_hat``.</span>
<span class="sd">        aleatoric : np.array</span>
<span class="sd">            Represents ``RiskTensor.aleatoric``.</span>
<span class="sd">        epistemic : np.array</span>
<span class="sd">            Represents ``RiskTensor.epistemic``.</span>
<span class="sd">        bias : np.array</span>
<span class="sd">            Represents ``RiskTensor.bias``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">EagerTensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;RiskTensor.numpy() is only supported in eager mode.&quot;</span><span class="p">)</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">aleatoric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aleatoric</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">epistemic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epistemic</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">aleatoric</span><span class="p">,</span> <span class="n">epistemic</span><span class="p">,</span> <span class="n">bias</span></div>

    <span class="k">class</span> <span class="nc">Spec</span><span class="p">:</span>
        <span class="c1"># Need this only for feeding RiskTensor to the Keras model.</span>
        <span class="c1"># If we don&#39;t subclass it we&#39;d need to rely on the automatically generated typespec, which can be</span>
        <span class="c1"># retrieved by ``tf.type_spec_from_value(mt)``. However his leads to ``ValueError: KerasTensor only</span>
        <span class="c1"># supports TypeSpecs that have a shape field; got MaskedTensor.Spec, which does not have a shape.``</span>
        <span class="c1"># To customize the TypeSpec, we define our own class named Spec, and ``ExtensionType`` will use that</span>
        <span class="c1"># as the basis for the automatically constructed TypeSpec.</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_hat</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Keras requires TypeSpec to have a `with_shape` method that returns a copy of `self` with an updated shape.</span>
        <span class="k">def</span> <span class="nf">with_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RiskTensor</span><span class="o">.</span><span class="n">Spec</span><span class="p">(</span>
                <span class="n">shape</span><span class="p">,</span>
            <span class="p">)</span></div>


<span class="c1">#######################</span>
<span class="c1"># convenience functions</span>
<span class="c1">#######################</span>


<span class="k">def</span> <span class="nf">_fill_nan_risk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fills empty elements of a ``RiskTensor`` (the risk</span>
<span class="sd">    estimates that are ``None``) with the provided values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;keep&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">replace_risk</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">),</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">epistemic</span><span class="p">),</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bias</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_risk</span><span class="p">(</span><span class="n">risk_tens</span><span class="p">):</span>
    <span class="n">is_aleatoric</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">risk_tens</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">)</span>
    <span class="n">is_epistemic</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">risk_tens</span><span class="o">.</span><span class="n">epistemic</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">)</span>
    <span class="n">is_bias</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">risk_tens</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">is_aleatoric</span><span class="p">,</span> <span class="n">is_epistemic</span><span class="p">,</span> <span class="n">is_bias</span>


<span class="k">def</span> <span class="nf">_are_all_risk</span><span class="p">(</span><span class="n">list_risk_tens</span><span class="p">):</span>
    <span class="n">is_aleatoric</span><span class="p">,</span> <span class="n">is_epistemic</span><span class="p">,</span> <span class="n">is_bias</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">risk_tens</span> <span class="ow">in</span> <span class="n">list_risk_tens</span><span class="p">:</span>
        <span class="n">temp_is_aleatoric</span><span class="p">,</span> <span class="n">temp_is_epistemic</span><span class="p">,</span> <span class="n">temp_is_bias</span> <span class="o">=</span> <span class="n">_is_risk</span><span class="p">(</span><span class="n">risk_tens</span><span class="p">)</span>
        <span class="n">is_aleatoric</span> <span class="o">&amp;=</span> <span class="n">temp_is_aleatoric</span>
        <span class="n">is_epistemic</span> <span class="o">&amp;=</span> <span class="n">temp_is_epistemic</span>
        <span class="n">is_bias</span> <span class="o">&amp;=</span> <span class="n">temp_is_bias</span>

    <span class="k">return</span> <span class="n">is_aleatoric</span><span class="p">,</span> <span class="n">is_epistemic</span><span class="p">,</span> <span class="n">is_bias</span>


<span class="k">def</span> <span class="nf">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function used in dispatch for apis to avoid code duplication as most of them require almost</span>
<span class="sd">    the same logic except for the name of the api. The function is used for apis that operate on a single</span>
<span class="sd">    risk tensor.</span>

<span class="sd">    Similar to the `RuggedTensor &lt;https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/ragged/ragged_math_ops.py#L476-L692&gt;`_</span>
<span class="sd">    which implements one base function and reuses it for multiple different apis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_aleatoric</span><span class="p">,</span> <span class="n">is_epistemic</span><span class="p">,</span> <span class="n">is_bias</span> <span class="o">=</span> <span class="n">_is_risk</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">RiskTensor</span><span class="p">(</span>
        <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">y_hat</span><span class="p">),</span>
        <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_aleatoric</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">epistemic</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_epistemic</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_bias</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">base_list_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">lis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function used in dispatch for apis to avoid code duplication as most of them require almost</span>
<span class="sd">    the same logic except for the name of the api. The function is used for apis that operate on a list of</span>
<span class="sd">    risk tensors.</span>

<span class="sd">    Loop over the ``RiskTensors`` passed to an api, if any one of them</span>
<span class="sd">    doesn&#39;t have e.g. aleatoric risk estimate do not run the api on aleatoric risks</span>
<span class="sd">    (even if the other tensors passed to the api do have risk estimate of this type)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">are_all_aleatoric</span><span class="p">,</span> <span class="n">are_all_epistemic</span><span class="p">,</span> <span class="n">are_all_bias</span> <span class="o">=</span> <span class="n">_are_all_risk</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">RiskTensor</span><span class="p">(</span>
        <span class="n">api</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">y_hat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">]),</span>
        <span class="n">api</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">aleatoric</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">])</span> <span class="k">if</span> <span class="n">are_all_aleatoric</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">api</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">epistemic</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">])</span> <span class="k">if</span> <span class="n">are_all_epistemic</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">api</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">bias</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">])</span> <span class="k">if</span> <span class="n">are_all_bias</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">base_x_y</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">is_wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function used in dispatch for apis to avoid code duplication as most of them require almost</span>
<span class="sd">    the same logic except for the name of the api.</span>

<span class="sd">    The function is used for apis that operate on (i) two risk tensors, or (ii) on a risk tensor and on an object</span>
<span class="sd">    of a different type (not a risk tensor). And encapsulates some logic of how an api should process these inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">):</span>
        <span class="n">are_both_aleatoric</span><span class="p">,</span> <span class="n">are_both_epistemic</span><span class="p">,</span> <span class="n">are_both_bias</span> <span class="o">=</span> <span class="n">_are_all_risk</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="n">aleatoric</span> <span class="o">=</span> <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">)</span> <span class="k">if</span> <span class="n">are_both_aleatoric</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">epistemic</span> <span class="o">=</span> <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">epistemic</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">epistemic</span><span class="p">)</span> <span class="k">if</span> <span class="n">are_both_epistemic</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span> <span class="k">if</span> <span class="n">are_both_bias</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">y_hat</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">y_hat</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">y_hat</span><span class="p">,</span> <span class="n">aleatoric</span><span class="p">,</span> <span class="n">epistemic</span><span class="p">,</span> <span class="n">bias</span> <span class="o">=</span> <span class="n">api</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># This function (base_x_y) is called by our modified dispatchers, a single dispatcher</span>
        <span class="c1"># is implemented to expect all relevant combinations of input types, following</span>
        <span class="c1"># https://github.com/tensorflow/tensorflow/blob/359c3cdfc5fabac82b3c70b3b6de2b0a8c16874f/tensorflow/python/ops/ragged/ragged_dispatch.py#L36-L78</span>
        <span class="c1"># So this function gets called by another function which expects</span>
        <span class="c1"># x: Union[RiskTensor, tf.Tensor, np.ndarray, ...], y: Union[RiskTensor, tf.Tensor, np.ndarray, ...]</span>
        <span class="c1"># because apparently tf implements some mechanisms under the hood to prevent our modified dispatcher</span>
        <span class="c1"># from being invoked for e.g. (array and array) or (Tensor and Tensor) - this is desirable since</span>
        <span class="c1"># these cases should be handled by the dispatchers of other types e.g. Tensor&#39;s (not RiskTensor&#39;s).</span>
        <span class="c1"># Here we just take an extra precaution and rase the error if this dispatcher gets invoked for</span>
        <span class="c1"># non RiskTensor inputs.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected at least one of the inputs to be a RiskTensor, saw </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">is_wrap</span><span class="p">:</span>
        <span class="c1"># wrap into a risk tensor</span>
        <span class="k">return</span> <span class="n">RiskTensor</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">aleatoric</span><span class="p">,</span> <span class="n">epistemic</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="c1">##########################</span>
<span class="c1"># dispatch for unary and</span>
<span class="c1"># binary element wise apis</span>
<span class="c1">##########################</span>


<div class="viewcode-block" id="unary_elementwise_op_handler"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.unary_elementwise_op_handler">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_unary_elementwise_apis</span><span class="p">(</span><span class="n">RiskTensor</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unary_elementwise_op_handler</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Note: By design the `unary operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_unary_elementwise_apis&gt;`_</span>
<span class="sd">    are performed on ``y_hat`` only. E.g. ``tf.abs(output)`` will only take the absolute values of the</span>
<span class="sd">    ``y_hat`` tensor, leaving the risk tensors untouched.</span>

<span class="sd">    The reasoning behind such a design choice is to protect a user from accidentally modifying the</span>
<span class="sd">    contents of risk tensors when the user intends to treat outputs of a metric wrapper as ``y_hat``.</span>

<span class="sd">    Thus, you need to explicitly select other elements to perform uniary operations on them e.g.</span>
<span class="sd">    ``tf.abs(output.epistemic)`` to select absolute values of the epistemic tensor.</span>

<span class="sd">    For more details see `dispatch for all unary elementwise APIs &lt;https://www.tensorflow.org/guide/extension_type#dispatch_for_all_unary_elementwise_apis&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RiskTensor</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">y_hat</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">aleatoric</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">epistemic</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span></div>


<div class="viewcode-block" id="binary_elementwise_op_handler"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.binary_elementwise_op_handler">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_binary_elementwise_apis</span><span class="p">(</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">binary_elementwise_op_handler</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The decorated function (known as the &quot;elementals api handler&quot;) overrides the default implementation for any binary elementals API,</span>
<span class="sd">    whenever the value for the first two arguments (typically named ``x`` and ``y``) match the specified type annotations.</span>
<span class="sd">    For more details see `dispatch for binary elementwise APIs &lt;https://www.tensorflow.org/guide/extension_type#dispatch_for_binary_all_elementwise_apis&gt;`_.</span>

<span class="sd">    Note: By design the `binary operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_binary_elementwise_apis&gt;`_</span>
<span class="sd">    for two ``RiskTensor``&#39;s are performed on ``y_hat`` tensors, as well as on the risk tensors (if both of them are not ``None``).</span>

<span class="sd">    The reasoning behind such a design choice is that in this scenario when operations are performed on two</span>
<span class="sd">    ``RiskTensor``&#39;s (`not` on a ``RiskTensor`` and e.g. a ``tf.Tensor``) there&#39;s no need to protect a user</span>
<span class="sd">    from accidentally modifying their risk contents because both inputs of the binary operation have the</span>
<span class="sd">    same type.</span>

<span class="sd">    Thus, you don&#39;t need to explicitly select other elements to perform binary operations on them e.g.</span>
<span class="sd">    ``tf.subtract(output1.epistemic, output2.epistemic)`` to subtract values of the epistemic tensors,</span>
<span class="sd">    simply calling ``tf.subtract(output1, output2)`` will subtract all elements of the risk tensors.</span>

<span class="sd">    Note: By design the `binary operations &lt;https://www.tensorflow.org/api_docs/python/tf/experimental/dispatch_for_binary_elementwise_apis&gt;`_</span>
<span class="sd">    for a ``RiskTensor`` and a ``Union[tf.Tensor, np.ndarray, int, float]`` are performed on ``y_hat`` only.</span>

<span class="sd">    The reasoning behind such a design choice is that e.g. ``tf.Tensor`` simply doesn&#39;t have the</span>
<span class="sd">    risk elements to perform a binary operation on.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">base_x_y</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<span class="c1">####################</span>
<span class="c1"># dispatch for apis</span>
<span class="c1">####################</span>

<span class="c1">### operate on one element</span>


<div class="viewcode-block" id="risk_shape"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_shape">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_shape</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.shape`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">out_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_size"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_size">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_size</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.size`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">out_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_convert_to_tensor"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_convert_to_tensor">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_convert_to_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype_hint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.convert_to_tensor`` should process ``RiskTensor`` values.</span>

<span class="sd">    Since when initializing a risk tensor we already call ``tf.convert_to_tensor``</span>
<span class="sd">    on every element of the tensor if running ``tf.convert_to_tensor`` on</span>
<span class="sd">    a risk tensor no need convert again.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">value</span></div>


<span class="c1">### operate on one risk tensor</span>


<div class="viewcode-block" id="risk_reshape"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_reshape">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_reshape</span><span class="p">(</span><span class="n">tensor</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.reshape`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">tensor</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_reduce_all"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_reduce_all">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_reduce_all</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.reduce_all`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_reduce_std"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_reduce_std">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">reduce_std</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_reduce_std</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.math.reduce_std`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">reduce_std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_reduce_mean"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_reduce_mean">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_reduce_mean</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.reduce_mean`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_reduce_sum"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_reduce_sum">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_reduce_sum</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.reduce_sum`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_transpose"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_transpose">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_transpose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">RiskTensor</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conjugate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;transpose&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.transpose`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></div>


<span class="c1">### operate on list of risk tensors</span>


<div class="viewcode-block" id="risk_stack"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_stack">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_stack</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.stack`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_list_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_concat"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_concat">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_concat</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;concat&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.concat`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_list_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_add_n"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_add_n">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">add_n</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_add_n</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.add_n`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">api</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">add_n</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_list_x</span><span class="p">(</span><span class="n">api</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span></div>


<span class="c1">### operate on two of risk tensors</span>


<div class="viewcode-block" id="risk_where"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_where">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_where</span><span class="p">(</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.where`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition</span><span class="o">.</span><span class="n">y_hat</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">condition</span>
    <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x_y</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_assert_near"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_assert_near">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_near</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_assert_near</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.debugging.assert_near`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>

    <span class="c1"># account for the fact that tf.debugging.assert_near(&lt;RiskTensor: risk=(aleatoric,)&gt;,</span>
    <span class="c1"># &lt;RiskTensor: risk=(None)&gt;) should fail. So the logic of are_both_aleatoric, are_both_epistemic, ...</span>
    <span class="c1"># does not work here -- if we&#39;re running this op on two risk tensors and one of them doesn&#39;t have</span>
    <span class="c1"># e.g. aleatoric uncertainty, we can&#39;t simply skip running the op on these elements of the risk tensors.</span>
    <span class="c1"># But can&#39;t use this op if either x or y is None, so use -1. as a filler. Can&#39;t use np.inf as a filler,</span>
    <span class="c1"># because in this case tf.debugging.assert_near(output_none, output_none) fails as well, which is not desirable.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_fill_nan_risk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_fill_nan_risk</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>

    <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_near</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">name</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x_y</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">is_wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="risk_assert_equal"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_assert_equal">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_assert_equal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.debugging.assert_equal`` should process ``RiskTensor`` values.&quot;&quot;&quot;</span>

    <span class="c1"># see ``risk_assert_near`` for comments</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_fill_nan_risk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_fill_nan_risk</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>

    <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">base_x_y</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">is_wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="c1">### nn related</span>


<div class="viewcode-block" id="risk_matmul"><a class="viewcode-back" href="../../api_documentation/RiskTensor.html#capsa.risk_matmul">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">dispatch_for_api</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">risk_matmul</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RiskTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">transpose_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">transpose_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">adjoint_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">adjoint_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">a_is_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">b_is_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">output_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specifies how ``tf.matmul`` should process ``RiskTensor`` values.</span>

<span class="sd">    Since the ``tf.matmul`` API is used by standard Keras layers</span>
<span class="sd">    (e.g. ``tf.keras.layers.Dense``), overriding it allows us to use</span>
<span class="sd">    those layers with a ``RiskTensor``. Concretely, in the case of e.g.</span>
<span class="sd">    feeding a ``RiskTensor`` to a dense layer, ``tf.matmul`` gets called</span>
<span class="sd">    with a ``RiskTensor`` (input) as one argument and a ``tf.Variable``</span>
<span class="sd">    (weight) as another -- thus this function gets called.</span>

<span class="sd">    In the case described above the output is defined to not include the risk</span>
<span class="sd">    values in the product. In other words, returns just e.g. ``a.y_hat @ b``,</span>
<span class="sd">    and not a ``RiskTensor``. Thus, we can construct a Keras model that</span>
<span class="sd">    accepts ``RiskTensor`` inputs, using standard Keras layers.</span>

<span class="sd">    When both of the inputs to the ``tf.matmul`` are ``RiskTensor``&#39;s</span>
<span class="sd">    the corresponding elements of these tensors are matrix multiplied</span>
<span class="sd">    and a new ``RiskTensor`` is returned.</span>

<span class="sd">    See ``binary_elementwise_op_handler`` for the logic behind these design choices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">b</span><span class="p">,</span>
        <span class="n">transpose_a</span><span class="p">,</span>
        <span class="n">transpose_b</span><span class="p">,</span>
        <span class="n">adjoint_a</span><span class="p">,</span>
        <span class="n">adjoint_b</span><span class="p">,</span>
        <span class="n">a_is_sparse</span><span class="p">,</span>
        <span class="n">b_is_sparse</span><span class="p">,</span>
        <span class="n">output_type</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">risk_tens</span> <span class="o">=</span> <span class="n">base_x_y</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">RiskTensor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">risk_tens</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="n">risk_tens</span><span class="o">.</span><span class="n">y_hat</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, Themis AI Inc
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>